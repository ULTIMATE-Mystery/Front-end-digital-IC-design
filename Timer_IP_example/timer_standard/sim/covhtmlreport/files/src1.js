var g_data = {"name":"../tb/test_bench.v","src":"module test_bench;\n\n    parameter   ADDR_TCR    =   12'h0;\n    parameter   ADDR_TDR0   =   12'h4;\n    parameter   ADDR_TDR1   =   12'h8;\n    parameter   ADDR_TCMP0  =   12'hC;\n    parameter   ADDR_TCMP1  =   12'h10;\n    parameter   ADDR_TIER   =   12'h14;\n    parameter   ADDR_TISR   =   12'h18;\n    parameter   ADDR_THCSR  =   12'h1C;\n\n    parameter   APB_CYCLE   =   1     ;\n    \n    reg  clk, rst_n;\n    reg  psel, pwrite, penable,dbg_mode;\n    reg  [11:0] paddr;\n    reg  [31:0] pwdata;\n    reg  [3:0 ] pstrb;\n    wire [31:0] prdata;\n    wire          pready;\n    wire          tim_int;\n    wire        pslverr;\n    integer     err;\n\n    reg cnt_chk_en;\n    reg [31:0] cnt_chk_cycle;\n    reg [3:0]  div_val;\n    reg [63:0] exp_cnt;      \n\n    reg golden_cnt_cfg_en   ;\n    reg [63:0] golden_cnt_cfg;\n    wire [63:0] golden_cnt;\n\n    reg apb_err_psel;\n    reg apb_err_penable;\n    reg pslverr_chk_fail, pready_chk_fail;\n\n    \n    //instance DUT\n    timer_top u_timer \n    (\n        .sys_clk    (   clk     ),\n        .sys_rst_n  (   rst_n   ),\n        .tim_psel   (   psel    ),\n        .tim_pwrite (   pwrite  ),\n        .tim_penable(   penable ),\n        .tim_paddr   (  paddr    ),\n        .tim_pwdata  (  pwdata   ),\n        .tim_prdata  (  prdata   ),\n        .tim_pready  (  pready   ),\n        .tim_pstrb   (   pstrb    ),\n        .tim_pslverr (  pslverr  ),\n        .dbg_mode  ( dbg_mode ) ,\n        .tim_int ( tim_int )\n\n    );\n\n    mod_golden_cnt u_tb_cnt\n    (\n        .cnt_cfg_en (   golden_cnt_cfg_en   ),\n        .cnt_cfg    (   golden_cnt_cfg      ),\n        .cnt        (   golden_cnt          ),\n        .*\n    );\n\n\n\n    `include \"run_test.v\"\n  	\n    initial begin \n  	  clk = 0;\n  	  forever #25 clk = ~clk;\n  	end\n\n  	initial begin\n  	  rst_n = 1'b0;\n  	  #25 rst_n = 1'b1;\n  	end\n\n    initial begin\n        #100;\n        run_test();\n        #100;\n        $finish;\n    end\n\n\n    initial begin\n        paddr = 0;\n        pwdata = 0;\n        psel = 0;\n        penable = 0;\n        pwrite = 0;\n        dbg_mode = 0;\n        pstrb = 0;\n        err = 0;\n        cnt_chk_cycle = 0;\n        div_val = 0;\n        golden_cnt_cfg_en = 0   ;\n        golden_cnt_cfg      = 0  ;\n        apb_err_psel = 0;\n        apb_err_penable = 0;\n        pslverr_chk_fail = 0;\n        pready_chk_fail = 0;\n        \n        #100;\n    end\n\n    //initial begin\n    //    wait( rst_n == 1);\n    //    wait( pslverr == 1 );\n    //    pslverr_chk_fail = 1;\n    //    $display(\"ERROR: PSLVERR is not 0\");\n    //    err = 1;\n    //    \n    //end\n    //initial begin\n    //    wait( rst_n == 1);\n    //    wait( pready == 0 );\n    //    pready_chk_fail = 1;\n    //    $display(\"ERROR: PREADY is not 1\");\n    //    err = 1;\n    //end\n\n    task apb_wr;\n        input   [31:0]  in_addr;\n        input   [31:0]  in_data;\n\n        begin\n			$display(\"t=%10d [TB_WRITE]: addr=%x data=%x\",$time,in_addr, in_data);\n        \n            @(posedge clk);\n            #1;\n            psel = 1 & !apb_err_psel;   //setup phase\n            pwrite = 1;\n            paddr = in_addr;\n            pwdata = in_data; //cnt_en\n            @(posedge clk);\n            #1;\n            penable = 1 & !apb_err_penable; //access phase\n            wait( pready == 1); //wait accept\n            @(posedge clk);\n            #1;\n            pwrite = 0; //idle\n            psel = 0;\n            penable = 0;\n            paddr = 0;\n            pwdata = 0;\n        end\n\n    endtask\n    \n    task apb_rd;\n\n        input   [31:0]  in_addr;\n        output  [31:0]  out_rdata;\n        \n        begin\n        \n            @(posedge clk);\n            #1;\n            psel = 1 & !apb_err_psel;   //setup phase\n            pwrite = 0;\n            paddr = in_addr;\n            @(posedge clk);\n            #1;\n            penable = 1 & !apb_err_penable; //access phase\n            wait( pready == 1); //wait accept\n            #1;\n            out_rdata = prdata; \n\n            @(posedge clk);\n            \n            pwrite = 0; //idle\n            psel = 0;\n            penable = 0;\n            paddr = 0;\n            pwdata = 0;\n			\n			$display(\"t=%10d [TB_READ]: addr=%x rdata=%x\",$time,in_addr, out_rdata);\n        end\n    endtask\n\n\n    task cmp_data;\n        input [31:0]  in_addr ;\n        input [31:0]  in_data ;\n        input [31:0]  exp_data;\n        input [31:0]  mask;\n  	    \n		if( (in_data & mask) !== (exp_data & mask) ) begin\n			$display(\"------------------------------------------------\");\n			$display(\"t=%10d FAIL: rdata at addr %x is not correct\",$time, in_addr);\n			$display(\"Exp: %x Actual:%x\",exp_data & mask, in_data & mask);\n			$display(\"------------------------------------------------\");\n            #100;\n            err=err+1;\n		end else begin\n			$display(\"------------------------------------------------\");\n			$display(\"t=%10d PASS: rdata = %x at addr %x is correct\",$time,in_data, in_addr);\n			$display(\"------------------------------------------------\");\n		end\n        \n    endtask\n\n    task reg_init_chk;\n        reg [31:0]  task_rdata;\n        begin\n      	    \n            apb_rd( ADDR_TCR, task_rdata);\n            cmp_data( ADDR_TCR, task_rdata, 32'h0000_0100, 32'hffff_ffff);\n            \n            apb_rd( ADDR_TDR0, task_rdata);\n            cmp_data( ADDR_TDR0, task_rdata, 32'h0000_0000, 32'hffff_ffff);\n            \n            apb_rd( ADDR_TDR1, task_rdata);\n            cmp_data( ADDR_TDR1, task_rdata, 32'h0000_0000, 32'hffff_ffff);\n            \n            apb_rd( ADDR_TCMP0, task_rdata);\n            cmp_data( ADDR_TCMP0, task_rdata, 32'hffff_ffff, 32'hffff_ffff);\n            \n            apb_rd( ADDR_TCMP1, task_rdata);\n            cmp_data( ADDR_TCMP1, task_rdata, 32'hffff_ffff, 32'hffff_ffff);\n            \n            apb_rd( ADDR_TIER, task_rdata);\n            cmp_data( ADDR_TIER, task_rdata, 32'h0000_0000, 32'hffff_ffff);\n            \n            apb_rd( ADDR_TISR, task_rdata);\n            cmp_data( ADDR_TISR, task_rdata, 32'h0000_0000, 32'hffff_ffff);\n    \n            apb_rd( ADDR_THCSR, task_rdata);\n            cmp_data( ADDR_THCSR, task_rdata, 32'h0000_0000, 32'hffff_ffff);\n    \n        end\n    endtask\n\n    task cnt_chk_no_halt;\n        integer idx;\n        begin\n            for( idx =0; idx < cnt_chk_cycle; idx = idx+1) begin\n                @(posedge clk); \n                #1;\n                if( div_val == 0 || (div_val!=0 && (idx > 0) && (idx % (1 << div_val)) == 0)) \n                    exp_cnt = exp_cnt + 1;\n            end\n        end\n\n    endtask\n\n    task tsk_cfg_golden_cnt;\n        input [63:0] val;\n\n        begin\n            @(posedge clk);\n            #1;\n            golden_cnt_cfg_en = 1;\n            golden_cnt_cfg      = val;\n            @(posedge clk);\n            #1;\n            golden_cnt_cfg_en = 0;\n            golden_cnt_cfg      = 0;\n            @(posedge clk);\n        end\n\n    endtask\n\nendmodule\n\n\nmodule mod_golden_cnt (\n    input wire clk       ,\n    input wire rst_n     ,\n    input wire psel      ,\n    input wire penable   ,\n    input wire pwrite    ,\n    input wire [11:0] paddr,\n    input wire [31:0] pwdata,\n    input wire cnt_cfg_en   ,\n    input wire [63:0] cnt_cfg,\n    output reg [63:0] cnt\n);\n    wire [63:0] cnt_next;\n    wire tim_en_wr_set;\n    wire tim_en_wr_clr;\n    reg  tim_en;\n   \n    assign tim_en_wr_set = psel & penable & pwrite & (paddr == 0) & pwdata[0];\n    assign tim_en_wr_clr = psel & penable & pwrite & (paddr == 0) & ~pwdata[0];\n\n    assign cnt_next = cnt_cfg_en ? cnt_cfg : \n                      tim_en     ? cnt + 1'b1:\n                      cnt        ;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if(!rst_n) \n            tim_en <= 1'b0;\n        else if( tim_en_wr_clr )\n            tim_en <= 1'b0;\n        else if( tim_en_wr_set )\n            tim_en <= 1'b1;\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if( !rst_n ) begin \n            cnt    <=  64'h0       ;\n        end else begin\n            cnt    <=  cnt_next; \n        end\n    end\n\nendmodule\n\n","lang":"verilog"};
processSrcData(g_data);