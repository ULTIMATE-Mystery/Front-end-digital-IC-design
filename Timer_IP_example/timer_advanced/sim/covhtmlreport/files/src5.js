var g_data = {"name":"../rtl/regset.v","src":"module regset \n(\n    input  wire         clk         ,\n    input  wire         rst_n       ,\n    input  wire         wr_en       ,\n    input  wire         rd_en       ,\n    input  wire [3:0]   pstrb       ,\n    input  wire [11:0]  addr        ,\n    input  wire [31:0]  wdata       ,\n    input  wire [63:0]  cnt         , //from cnt\n    input  wire         dbg_mode    , \n    output wire         pslverr     ,\n    output wire         tdr0_wr_sel , //to cnt\n    output wire         tdr1_wr_sel , //to cnt\n    output reg          div_en      ,\n    output reg  [3:0]   div_val     ,\n    output reg          timer_en    ,\n    output wire         timer_en_neg,\n    output wire         tim_int     ,\n    output wire         halt_req_out,\n    output wire [31:0]  rdata   \n);\n    parameter   ADDR_TCR    =   12'h0;\n    parameter   ADDR_TDR0   =   12'h4;\n    parameter   ADDR_TDR1   =   12'h8;\n    parameter   ADDR_TCMP0  =   12'hC;\n    parameter   ADDR_TCMP1  =   12'h10;\n    parameter   ADDR_TIER   =   12'h14;\n    parameter   ADDR_TISR   =   12'h18;\n    parameter   ADDR_THCSR  =   12'h1C;\n\n\n\n    reg [31:0]  rd;\n    reg [31:0]  tcmp0    ;   //reg\n    reg [31:0]  tcmp1    ;   //reg\n    reg         hw_int_en;   //reg\n    reg         sw_int_en;   //reg\n    reg         hw_int   ;   //reg\n    reg         halt_req ;   //reg\n    reg         timer_en_1d; //reg\n\n    wire        cr_wr_sel;\n    wire        tcmp0_wr_sel;\n    wire        tcmp1_wr_sel;\n    wire        tier_wr_sel;\n    wire        tisr_wr_sel;\n    wire        thcsr_wr_sel ;\n\n    wire        div_val_wr_en;\n    wire        div_val_wr_sel;\n    wire [3:0]  div_val_pre;\n    wire        div_en_pre;\n    wire        timer_en_pre;\n    wire [31:0] tcmp0_pre    ;  \n    wire [31:0] tcmp1_pre    ;  \n    wire        hw_int_en_pre;  \n    wire        hw_int_pre   ;  \n    wire        int_sig      ;\n    wire        halt_req_pre ;\n    wire        halt_ack     ;\n    wire        div_val_err  ;      //error condition of prohibited div_val\n    wire        div_val_tim_en_err; //error condition of changing div_val while timer_en is high\n    wire        div_en_tim_en_err;  //error condition of changing div_en while timer_en is high\n\n    //CR sel\n    assign cr_wr_sel        =   wr_en & (addr == ADDR_TCR);\n\n    //error cases\n    assign  div_val_err         =   cr_wr_sel & (wdata[11:8] > 8) & pstrb[1];\n    assign  div_val_tim_en_err  =   cr_wr_sel & (wdata[11:8] != div_val) & pstrb[1] & timer_en;\n    assign  div_en_tim_en_err  =   cr_wr_sel & (wdata[1] != div_en) & pstrb[0] & timer_en;\n    \n    \n    assign  div_val_wr_en   = (wdata[11:8] <= 4'h8);\n    assign  div_val_wr_sel  = div_val_wr_en & cr_wr_sel & pstrb[1];\n\n    assign  div_val_pre     = div_val_wr_sel & ~pslverr         ? wdata[11:8] : div_val;\n    assign  div_en_pre      = cr_wr_sel & pstrb[0] & ~pslverr   ? wdata[1]    : div_en ;\n    assign  timer_en_pre    = cr_wr_sel & pstrb[0] & ~pslverr   ? wdata[0]    : timer_en;\n\n    //CR : 0x00\n    always @(posedge clk or negedge rst_n) begin\n        if( !rst_n ) begin \n            div_val     <=  4'b0001;\n            div_en      <=  1'b0;\n            timer_en    <=  1'b0;\n        end else begin\n            div_val     <= div_val_pre  ;\n            div_en      <= div_en_pre   ;\n            timer_en    <= timer_en_pre ;\n        end\n    end\n\n    //timer_en_1d;\n    always @(posedge clk or negedge rst_n) begin\n        if( !rst_n ) begin \n            timer_en_1d    <=  1'b0;\n        end else begin\n            timer_en_1d    <= timer_en;\n        end\n    end\n\n    assign timer_en_neg = ~timer_en & timer_en_1d; //falling edge detector \n\n    assign  tdr0_wr_sel = wr_en & (addr == ADDR_TDR0); \n\n    assign  tdr1_wr_sel = wr_en & (addr == ADDR_TDR1); \n\n\n    assign  tcmp0_wr_sel = wr_en & (addr == ADDR_TCMP0); \n    assign  tcmp0_pre[ 7: 0]    = tcmp0_wr_sel & pstrb[0] ? wdata[ 7: 0] : tcmp0[ 7: 0];\n    assign  tcmp0_pre[15: 8]    = tcmp0_wr_sel & pstrb[1] ? wdata[15: 8] : tcmp0[15: 8];\n    assign  tcmp0_pre[23:16]    = tcmp0_wr_sel & pstrb[2] ? wdata[23:16] : tcmp0[23:16];\n    assign  tcmp0_pre[31:24]    = tcmp0_wr_sel & pstrb[3] ? wdata[31:24] : tcmp0[31:24];\n    //TCMP0 : 0x0C\n    always @(posedge clk or negedge rst_n) begin\n        if( !rst_n ) begin \n            tcmp0    <=  32'hFFFF_FFFF       ;\n        end else begin\n            tcmp0    <=  tcmp0_pre    ;\n        end\n    end\n    \n    assign  tcmp1_wr_sel = wr_en & (addr == ADDR_TCMP1); \n    assign  tcmp1_pre[ 7: 0]    = tcmp1_wr_sel & pstrb[0] ? wdata[ 7: 0] : tcmp1[ 7: 0];\n    assign  tcmp1_pre[15: 8]    = tcmp1_wr_sel & pstrb[1] ? wdata[15: 8] : tcmp1[15: 8];\n    assign  tcmp1_pre[23:16]    = tcmp1_wr_sel & pstrb[2] ? wdata[23:16] : tcmp1[23:16];\n    assign  tcmp1_pre[31:24]    = tcmp1_wr_sel & pstrb[3] ? wdata[31:24] : tcmp1[31:24];\n    //TCMP1 : 0x10\n    always @(posedge clk or negedge rst_n) begin\n        if( !rst_n ) begin \n            tcmp1    <=  32'hFFFF_FFFF       ;\n        end else begin\n            tcmp1    <=  tcmp1_pre    ;\n        end\n    end\n\n\n    assign  tier_wr_sel = wr_en & (addr == ADDR_TIER); \n    assign  hw_int_en_pre  = tier_wr_sel & pstrb[0] ? wdata[0] : hw_int_en;\n    //TIER : 0x14\n    always @(posedge clk or negedge rst_n) begin\n        if( !rst_n ) begin \n            hw_int_en   <= 1'b0;\n        end else begin\n            hw_int_en   <= hw_int_en_pre;\n        end\n    end\n\n    //interrupt\n    assign  int_sig     = cnt == {tcmp1, tcmp0}; \n    \n    assign  tisr_wr_sel = wr_en & (addr == ADDR_TISR); \n    assign  hw_int_clr  = tisr_wr_sel & pstrb[0] & (wdata[0] == 1'b1) & (hw_int == 1'b1); \n    assign  hw_int_set  = int_sig;\n    assign  hw_int_pre  = hw_int_clr ? 1'b0 : \n                          hw_int_set ? 1'b1 : \n                          hw_int     ;\n    //TISR  : 0x18\n    always @(posedge clk or negedge rst_n) begin\n        if( !rst_n ) begin \n            hw_int   <= 1'b0;\n        end else begin\n            hw_int   <= hw_int_pre;\n        end\n    end\n\n    assign tim_int      = hw_int & hw_int_en;\n    \n    assign  thcsr_wr_sel = wr_en & (addr == ADDR_THCSR); \n    assign  halt_req_pre = thcsr_wr_sel & pstrb[0] ? wdata[0] : halt_req;\n    //THCSR : 0x1C\n    always @(posedge clk or negedge rst_n) begin\n        if( !rst_n ) begin \n            halt_req    <=  1'b0        ;\n        end else begin\n            halt_req    <=  halt_req_pre;\n        end\n    end\n\n\n    assign halt_ack = halt_req & dbg_mode;\n\n    //read logic\n    always @* begin\n        if( rd_en == 1'b1 ) begin\n            case (addr) \n                ADDR_TCR    :   rd = { 20'h0, div_val[3:0], 6'h0, div_en, timer_en }  ;\n                ADDR_TDR0   :   rd = cnt[31:0]              ;\n                ADDR_TDR1   :   rd = cnt[63:32]             ;\n                ADDR_TCMP0  :   rd = tcmp0                  ;\n                ADDR_TCMP1  :   rd = tcmp1                  ;\n                ADDR_TIER   :   rd = { 31'h0, hw_int_en }   ;\n                ADDR_TISR   :   rd = { 31'h0, hw_int    }   ;\n                ADDR_THCSR  :   rd = { 30'h0, halt_ack,halt_req  }   ;\n                default     :   rd = 32'h0                  ;\n            endcase\n        end else begin\n            rd = 32'h0; \n        end\n    end\n\n    assign rdata   = rd; \n    assign pslverr = div_val_err | div_val_tim_en_err | div_en_tim_en_err    ;\n    assign halt_req_out = halt_ack;\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);