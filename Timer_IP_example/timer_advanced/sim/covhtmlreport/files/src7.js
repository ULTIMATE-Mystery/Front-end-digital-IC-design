var g_data = {"name":"../rtl/cnt_ctrl.v","src":"module cnt_ctrl(\n    input  wire         clk     ,\n    input  wire         rst_n   ,\n    input  wire         div_en  ,\n    input  wire [3:0]   div_val ,\n    input  wire         timer_en,\n    input  wire         halt_req,\n    output wire         count_en\n);\n\n    reg  [7:0]  cnt     ;   //reg\n    reg         cnt_en;     //reg\n    reg  [7:0]  limit   ;\n    wire [7:0]  cnt_pre ;\n    wire        cnt_rst ;\n    wire        def_mode;\n    wire        ctrl_mode_0;\n    wire        ctrl_mode_other;\n    \n    //convert div_val to internal counter limit\n    always@* begin\n        case (div_val[3:0])\n            4'h1:   limit = 1;\n            4'h2:   limit = 3;\n            4'h3:   limit = 7;\n            4'h4:   limit = 15;\n            4'h5:   limit = 31;\n            4'h6:   limit = 63;\n            4'h7:   limit = 127;\n            4'h8:   limit = 255;\n            default:limit = 0;\n        endcase\n    end\n    //reset when internal cnt reach limit value\n    //or timer_en or div_en equal zero\n    assign cnt_rst  =  (cnt == limit) | (!timer_en) | (!div_en);\n\n    assign cnt_pre  =  halt_req        ? cnt :\n                       cnt_rst         ? 8'h0 :\n                       cnt + 1'b1      ; \n\n\n    always @(posedge clk or negedge rst_n) begin\n        if(!rst_n) begin\n            cnt         <= 8'h0;\n        end else begin\n            cnt         <= cnt_pre;\n        end\n    end\n\n\n    assign def_mode = timer_en & !div_en;\n    assign ctrl_mode_0 = timer_en & div_en & (div_val == 0);\n    assign ctrl_mode_other = timer_en & div_en & (div_val != 0);\n\n    //count_en logic\n    //counter_en is 1 in below condition\n    //default counting mode (div_en = 0)\n    //control counting mode & div_val = 0\n    //control couting mode and internal cnt reach limit value\n    assign count_en = (def_mode |  ctrl_mode_0 | (ctrl_mode_other & (cnt == limit))) & !halt_req;\n\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);