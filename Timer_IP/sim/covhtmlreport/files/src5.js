var g_data = {"name":"../rtl/timer_registers.v","src":"module timer_registers (\r\n    // System signals\r\n    input wire clk,\r\n    input wire rst_n,\r\n\r\n    // APB interface\r\n    input wire wr_en,\r\n    input wire rd_en,\r\n    input wire [12:0] reg_addr,\r\n    input wire [31:0] reg_wdata,\r\n    input wire [3:0]  reg_wstrb,\r\n    output reg [31:0] reg_rdata,\r\n    output reg reg_error,\r\n\r\n    // Counter module\r\n    output wire timer_en,\r\n    output wire [63:0] TDR,\r\n    output wire div_en,\r\n    output wire [3:0] div_val,\r\n    output wire halt_req,\r\n    output wire [63:0] tcmp,\r\n    output wire tdr0_wr_en,\r\n    output wire tdr1_wr_en,\r\n    input wire [63:0] cnt_val,\r\n    input wire cmp_match,\r\n    input wire halt_ack,\r\n\r\n    // Interrupt interface\r\n    output wire int_en,\r\n    output wire int_st\r\n);\r\n\r\n    // Register Definitions\r\n    reg [31:0] TCR;\r\n    reg [31:0] TDR0, TDR1;\r\n    reg [31:0] TCMP0, TCMP1;\r\n    reg [31:0] TIER, TISR, THCSR;\r\n\r\n    // Address Map\r\n    localparam TCR_ADDR   = 12'h00,\r\n               TDR0_ADDR  = 12'h04,\r\n               TDR1_ADDR  = 12'h08,\r\n               TCMP0_ADDR = 12'h0C,\r\n               TCMP1_ADDR = 12'h10,\r\n               TIER_ADDR  = 12'h14,\r\n               TISR_ADDR  = 12'h18,\r\n               THCSR_ADDR = 12'h1C;\r\n\r\n    // Control signals\r\n\r\n    wire valid_addr_space = (reg_addr <= 13'hFFF);\r\n\r\n    function [31:0] get_write_data;\r\n        input [31:0] reg_data;\r\n        input [31:0] reg_wdata;\r\n        input [3:0]  strb;\r\n        begin\r\n            get_write_data = (reg_wdata & {{8{strb[3]}}, {8{strb[2]}}, {8{strb[1]}}, {8{strb[0]}}}) |\r\n                             (reg_data & ~{{8{strb[3]}}, {8{strb[2]}}, {8{strb[1]}}, {8{strb[0]}}});\r\n        end\r\n    endfunction\r\n\r\n    // TCR register write error\r\n    wire tcr_wr_err = (wr_en && (reg_addr == TCR_ADDR)) && \r\n                 ((reg_wstrb[1] && (reg_wdata[11:8] > 4'h8)) || \r\n                 (TCR[0] && ((reg_wstrb[1] && (reg_wdata[11:8] != TCR[11:8])) || \r\n                            (reg_wstrb[0] && (reg_wdata[1] != TCR[1])))));\r\n\r\n    // Register Write Access\r\n    always @(posedge clk or negedge rst_n) begin\r\n        if (!rst_n) begin\r\n            TCR   <= 32'h0000_0100;\r\n            TDR0  <= 32'h0000_0000;\r\n            TDR1  <= 32'h0000_0000;\r\n            TCMP0 <= 32'hFFFF_FFFF;\r\n            TCMP1 <= 32'hFFFF_FFFF;\r\n            TIER  <= 32'h0000_0000;\r\n            TISR  <= 32'h0000_0000;\r\n            THCSR <= 32'h0000_0000;\r\n            reg_error <= 0;\r\n\r\n        end else begin\r\n            if (wr_en) begin\r\n                case (reg_addr)\r\n\r\n                    TCR_ADDR: begin\r\n                        if (tcr_wr_err) begin\r\n                            reg_error <= 1'b1;\r\n                        end else begin\r\n                            TCR <= get_write_data (TCR, reg_wdata, reg_wstrb);\r\n                        end\r\n                    end\r\n\r\n                    TDR0_ADDR: TDR0 <= get_write_data (TDR0, reg_wdata, reg_wstrb);                 \r\n\r\n                    TDR1_ADDR: TDR1 <= get_write_data (TDR1, reg_wdata, reg_wstrb);       \r\n\r\n                    TCMP0_ADDR: TCMP0 <= get_write_data (TCMP0, reg_wdata, reg_wstrb);\r\n\r\n                    TCMP1_ADDR: TCMP1 <= get_write_data (TCMP1, reg_wdata, reg_wstrb);\r\n\r\n                    TIER_ADDR:  TIER <= get_write_data (TIER, reg_wdata, reg_wstrb);\r\n\r\n                    TISR_ADDR: begin\r\n                        if (reg_wstrb[0] && reg_wdata[0]) begin\r\n                            TISR[0] <= 0;\r\n                        end else begin\r\n                            TISR[0] <= TISR[0];\r\n                        end\r\n                    end\r\n\r\n                    THCSR_ADDR: begin\r\n                        if (reg_wstrb[0]) begin\r\n                            THCSR[0] <= reg_wdata[0];\r\n                        end\r\n                    end\r\n\r\n                    default: begin\r\n                        // No default action required\r\n                    end\r\n                endcase\r\n            end\r\n        end\r\n    end\r\n\r\n    // Register Read Access\r\n    always @(*) begin\r\n        if (rd_en) begin\r\n            case (reg_addr)\r\n                TCR_ADDR:   reg_rdata = {20'h0, TCR[11:8], 6'h0, TCR[1], TCR[0]};\r\n                TDR0_ADDR:  reg_rdata = cnt_val [31:0];\r\n                TDR1_ADDR:  reg_rdata = cnt_val [63:32];\r\n                TCMP0_ADDR: reg_rdata = TCMP0;\r\n                TCMP1_ADDR: reg_rdata = TCMP1;\r\n                TIER_ADDR:  reg_rdata = {31'h0, TIER[0]};\r\n                TISR_ADDR:  reg_rdata = {31'h0, TISR[0]};\r\n                THCSR_ADDR: reg_rdata = {30'h0, THCSR[1], THCSR[0]};\r\n                default:    reg_rdata = 32'h0000_0000;\r\n            endcase\r\n        end else begin\r\n            reg_rdata = 32'h0;\r\n        end\r\n    end\r\n\r\n    // Set interrupt status flag when counter equals compare value\r\n    always @(posedge clk or negedge rst_n) begin\r\n        if (cmp_match) begin\r\n            TISR[0] <= 1'b1;\r\n        end else begin\r\n            TISR[0] <= TISR[0];\r\n        end\r\n    end\r\n\r\n    always @(posedge clk or negedge rst_n) begin\r\n        if (!rst_n)\r\n            THCSR[1] <= 1'b0;\r\n        else  \r\n            THCSR[1] <= halt_ack;  // Sync halt_ack into register\r\n    end\r\n\r\n    // Logic for `pslverr` (`reg_error`)\r\n    always @(*) begin\r\n        if (!valid_addr_space || tcr_wr_err) begin\r\n            reg_error = 1'b1;\r\n        end else begin\r\n            reg_error = 1'b0; // No error for valid address range, even if unmapped register address\r\n        end\r\n    end\r\n\r\n    assign tdr0_wr_en = wr_en && (reg_addr == TDR0_ADDR);\r\n    assign tdr1_wr_en = wr_en && (reg_addr == TDR1_ADDR);\r\n\r\n    // Output Assignments\r\n    assign timer_en = TCR[0];\r\n    assign div_en = TCR[1];\r\n    assign div_val = TCR[11:8];\r\n    assign halt_req = THCSR[0];\r\n    assign TDR = {TDR1, TDR0};\r\n    assign tcmp = {TCMP1, TCMP0};\r\n    assign int_en = TIER[0];\r\n    assign int_st = TISR[0];\r\n\r\nendmodule","lang":"verilog"};
processSrcData(g_data);